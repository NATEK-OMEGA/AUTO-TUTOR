import streamlit as st
from typing import List, Tuple, Dict, Any
import math

# Configure page metadata for social sharing and browser display
st.set_page_config(
    page_title="Quadratic Sequence Tutor | CAPS Grade 11",
    page_icon="Autotutor.png",
    layout="wide",
    initial_sidebar_state="expanded",
    menu_items={
        "About": "Quadratic Sequence Tutor - CAPS Grade 11 Mathematics\nBuilt with Streamlit for educational use."
    }
)


def compute_quadratic_from_terms(seq: List[float]) -> Tuple[float, float, float, Dict[str, Any]]:
    """
    Given a sequence of numeric terms (length >= 3), assume it's generated by
    T(n) = a n^2 + b n + c for n = 1,2,... and compute a, b, c.

    Returns (a, b, c, details) where details contains step-by-step explanations
    and verification values for display.
    """
    if len(seq) < 3:
        raise ValueError("Need at least 3 terms to determine a quadratic")

    # first differences
    d1 = [seq[i + 1] - seq[i] for i in range(len(seq) - 1)]
    # second differences
    d2 = [d1[i + 1] - d1[i] for i in range(len(d1) - 1)]

    details: Dict[str, Any] = {
        "sequence": seq,
        "d1": d1,
        "d2": d2,
        "explanations": [],
        "step_texts": {},
    }

    # Add classroom-style explanation about differences
    details["step_texts"]["what_differences"] = (
        "First differences are found by subtracting each term from the next: "
        "they show how the sequence changes from term to term. Second differences "
        "are differences of those first differences. For quadratic sequences the second "
        "differences are constant."
    )
    details["step_texts"]["teacher_note_differences"] = (
        "This difference method is the foundation of sequence analysis in CAPS. It's visual, intuitive, and builds "
        "problem-solving skills. Students should practise: it trains algebraic thinking and pattern recognition."
    )

    # Check second difference consistency (allowing tiny float tolerance)
    tol = 1e-9
    if not all(abs(d2[i] - d2[0]) <= tol for i in range(len(d2))):
        details["explanations"].append("Second differences are not constant; sequence is not quadratic.")
        details["step_texts"]["why_not_quadratic"] = (
            "Because the second differences are not the same the sequence cannot be exactly "
            "represented by a quadratic polynomial of the form T(n)=an^2+bn+c."
        )
        raise ValueError("Sequence does not have constant second difference (not quadratic)")

    second_diff = d2[0]
    a = second_diff / 2.0
    details["explanations"].append(f"Second difference = {second_diff} â†’ a = second_diff/2 = {a}")
    details["step_texts"]["compute_a"] = (
        "The second difference for a quadratic sequence equals 2a. So divide the constant "
        "second difference by 2 to find a."
    )
    details["step_texts"]["teacher_note_a"] = (
        "Why does the second difference equal 2a? For a quadratic T(n)=anÂ²+bn+c, the first differences form "
        "a linear sequence with slope 2a. The constant difference between these linear first differences is always 2a. "
        "This is a key property used in CAPS curriculum to identify and solve quadratic sequences."
    )

    # Use first two terms to solve for b and c:
    # T1 = a*1^2 + b*1 + c  => a + b + c = T1
    # T2 = a*2^2 + b*2 + c  => 4a + 2b + c = T2
    # Subtract: (4a+2b+c) - (a+b+c) = 3a + b = T2 - T1  => b = (T2-T1) - 3a
    T1 = seq[0]
    T2 = seq[1]
    dT = T2 - T1
    b = dT - 3 * a
    c = T1 - a - b

    details["explanations"].append(f"T1 = {T1}, T2 = {T2}; T2 - T1 = {dT}")
    details["step_texts"]["explain_T1_T2"] = (
        "We substitute n=1 and n=2 into T(n)=an^2+bn+c to form two equations:",
    )
    details["step_texts"]["teacher_note_equations"] = (
        "The general term T(n)=anÂ²+bn+c is a polynomial with three unknowns. We need three independent equations "
        "to solve for a, b, and c uniquely. We already have 'a' from the second difference, so we form two equations "
        "from the first and second terms. This system of linear equations can be solved by eliminationâ€”a fundamental "
        "algebraic technique taught in Grade 10-11 CAPS algebra."
    )
    details["step_texts"]["compute_b"] = (
        "Subtract the two equations to eliminate c: (4a+2b+c) - (a+b+c) = 3a + b. "
        "So b = (T2 - T1) - 3a."
    )
    details["step_texts"]["teacher_note_b"] = (
        "Elimination is a powerful strategy: by subtracting equation (1) from equation (2), the constant term 'c' "
        "cancels out. This is intentionalâ€”we design our equations to eliminate unknowns strategically. "
        "Students should practise this technique: identify which equations to use and which variable to eliminate."
    )
    details["step_texts"]["compute_c"] = (
        "Finally, substitute a and b back into a + b + c = T1 to solve for c."
    )
    details["step_texts"]["teacher_note_c"] = (
        "Back-substitution completes the solution. Once we know a and b, we can substitute them into any of our "
        "original equations to find c. This is the third step of the elimination method. Emphasise that the choice "
        "of which equation to use doesn't matterâ€”they're equivalent; all should give the same answer (a good verification check)."
    )
    details["explanations"].append(f"3a + b = T2 - T1 â†’ b = {dT} - 3Ã—{a} = {b}")
    details["explanations"].append(f"c = T1 - a - b = {T1} - {a} - {b} = {c}")

    # Verification: generate terms from computed formula and compare
    generated = [a * (n ** 2) + b * n + c for n in range(1, len(seq) + 1)]
    details["generated"] = generated
    details["explanations"].append("Verification: Generated terms using computed a,b,c should match input sequence.")
    details["step_texts"]["verification"] = (
        "To verify, we generate terms from the formula T(n)=an^2+bn+c for the same n values. "
        "If the generated terms match the input sequence the formula is correct."
    )
    details["step_texts"]["teacher_note_verification"] = (
        "Verification is not optionalâ€”it's essential mathematical practice. Always substitute back into the original "
        "problem to check your answer. In this case, our formula should reproduce the input sequence exactly. "
        "If it doesn't, we've made an error somewhere in our calculations (or the sequence isn't quadratic). "
        "This builds problem-solving habits and mathematical rigour."
    )

    return a, b, c, details


def format_steps(details: Dict[str, Any]) -> List[str]:
    # This function is no longer used to directly render to screen, but kept
    # for backward compatibility. Prefer using `display_steps` which renders
    # LaTeX and nicely formatted integers.
    lines: List[str] = []
    lines.append("Given sequence: " + ", ".join(str(x) for x in details["sequence"]))
    lines.append("First differences: " + ", ".join(str(x) for x in details["d1"]))
    lines.append("Second differences: " + ", ".join(str(x) for x in details["d2"]))
    lines.extend(details.get("explanations", []))
    lines.append("Generated from formula: " + ", ".join(str(round(x, 8)) for x in details.get("generated", [])))
    return lines


def format_num_for_display(x: float) -> str:
    """Format number as integer if it's effectively whole, otherwise trim floats."""
    if abs(x - round(x)) < 1e-9:
        return str(int(round(x)))
    # remove trailing zeros
    s = f"{x:.8f}".rstrip('0').rstrip('.')
    return s


def latex_polynomial(a: float, b: float, c: float) -> str:
    A = format_num_for_display(a)
    B = format_num_for_display(abs(b))
    C = format_num_for_display(abs(c))
    parts = []
    parts.append(f"{A}n^{2}")
    parts.append(("+ " if b >= 0 else "- ") + f"{B}n")
    parts.append(("+ " if c >= 0 else "- ") + f"{C}")
    return " ".join(parts)


def latex_polynomial_elegant(a: float, b: float, c: float) -> str:
    """
    Format polynomial for Result display following mathematical etiquette:
    - Omit coefficient 1 (write n^2 instead of 1n^2)
    - Omit coefficient -1 (write -n instead of -1n)
    - Drop terms with coefficient 0 entirely
    """
    tol = 1e-9
    parts = []

    # Term: an^2
    if abs(a) > tol:
        a_disp = format_num_for_display(a)
        if abs(abs(a) - 1.0) < tol:  # coefficient is 1 or -1
            if a > 0:
                parts.append("n^{2}")
            else:
                parts.append("- n^{2}")
        else:
            if a > 0 and parts:  # not the first term
                parts.append(f"+ {a_disp}n^{{2}}")
            elif a < 0:
                parts.append(f"- {format_num_for_display(abs(a))}n^{{2}}")
            else:
                parts.append(f"{a_disp}n^{{2}}")

    # Term: bn
    if abs(b) > tol:
        b_disp = format_num_for_display(abs(b))
        if abs(abs(b) - 1.0) < tol:  # coefficient is 1 or -1
            if b > 0:
                if parts:
                    parts.append("+ n")
                else:
                    parts.append("n")
            else:
                parts.append("- n")
        else:
            if b > 0:
                if parts:
                    parts.append(f"+ {b_disp}n")
                else:
                    parts.append(f"{b_disp}n")
            else:
                parts.append(f"- {b_disp}n")

    # Term: c
    if abs(c) > tol:
        c_disp = format_num_for_display(abs(c))
        if c > 0:
            if parts:
                parts.append(f"+ {c_disp}")
            else:
                parts.append(f"{c_disp}")
        else:
            parts.append(f"- {c_disp}")

    # If all coefficients are zero (edge case), return "0"
    if not parts:
        return "0"

    return " ".join(parts)


def create_step_quiz(step_num: int, seq: List[float]) -> Tuple[str, float, str]:
    """
    Generate quiz questions for each step with mark allocations.
    Returns (question, marks, answer_key) tuple.
    """
    quizzes = {
        1: (
            f"Calculate the first differences for the sequence: {', '.join(format_num_for_display(x) for x in seq)}",
            2.0,
            ", ".join(format_num_for_display(seq[i+1] - seq[i]) for i in range(len(seq)-1))
        ),
        2: (
            f"Calculate the second differences from first differences.",
            2.0,
            "Use the first differences and subtract each from the next."
        ),
        3: (
            "If the second difference is constant, what property does this reveal about the sequence?",
            1.5,
            "The sequence is quadratic (can be represented by a quadratic polynomial T(n)=anÂ²+bn+c)"
        ),
        4: (
            "What is the relationship between the second difference and the coefficient 'a'?",
            1.5,
            "Second difference = 2a, so a = second difference Ã· 2"
        ),
        5: (
            "Explain why we form two equations by substituting n=1 and n=2.",
            2.0,
            "We have three unknowns (a, b, c), so we need three independent equations. "
            "We already found a from the second difference, so we need two more equations to solve for b and c."
        ),
    }
    return quizzes.get(step_num, ("", 0, ""))


def display_step_with_quiz(step_num: int, details: Dict[str, Any], seq: List[float], 
                           show_teacher_notes: bool = False) -> None:
    """Render a step with optional quiz and teacher notes."""
    question, marks, answer_key = create_step_quiz(step_num, seq)
    
    if question and marks > 0:
        st.write(f"**QUIZ (Step {step_num})** â€” {marks} marks")
        st.write(f"**Question:** {question}")
        
        # Try/reveal pattern
        if st.checkbox(f"Try this question first (marks: {marks})", key=f"quiz_try_{step_num}"):
            user_answer = st.text_area(f"Your answer for Step {step_num}:", key=f"answer_{step_num}")
            if st.button(f"Check answer", key=f"check_{step_num}"):
                st.info(f"**Expected answer:** {answer_key}")
                st.write("Review your answer above against the expected answer. Self-mark your work!")
        else:
            if st.button(f"Show answer", key=f"reveal_{step_num}"):
                st.success(f"**Answer:** {answer_key}")
        
        st.divider()


def display_steps(details: Dict[str, Any], a: float, b: float, c: float, 
                  show_teacher_notes: bool = False, show_quizzes: bool = False) -> None:
    # Display sequence and differences with integer formatting where possible
    seq_str = ", ".join(format_num_for_display(x) for x in details["sequence"]) 
    col_l, col_r = st.columns([2, 3])
    with col_l:
        st.latex(r"\textbf{Given\ sequence:}\ %s" % seq_str)
    with col_r:
        st.write("STEP 0 â€” What we are given: the first terms of the sequence.")
    
    if show_teacher_notes and "teacher_note_differences" in details.get("step_texts", {}):
        with st.expander("ðŸ“š Teacher Notes (Step 0)"):
            st.write(details["step_texts"].get("teacher_note_differences", ""))

    d1_str = ", ".join(format_num_for_display(x) for x in details["d1"]) 
    col_l, col_r = st.columns([2, 3])
    with col_l:
        st.latex(r"\textbf{First\ differences:}\ %s" % d1_str)
    with col_r:
        st.write("STEP 1 â€” Find first differences: subtract each term from the next to see how the sequence changes.")
    
    if show_teacher_notes:
        with st.expander("ðŸ“š Teacher Notes (Step 1)"):
            st.write("**First differences:** represent the rate of change. For a quadratic sequence, first differences form a linear sequence. "
                    "This is a key insight: quadratic â†’ linear first differences â†’ constant second differences.")
    
    if show_quizzes:
        st.info("**Interactive Quiz for Step 1** â€” 2 marks")
        if st.button("Try the Step 1 quiz", key="quiz_step1"):
            st.write("Calculate first differences for the given sequence.")
            student_answer = st.text_input("Enter first differences (comma-separated):", key="ans_step1")
            if st.button("Check", key="check_step1"):
                st.info(f"Expected: {d1_str}")
        st.divider()

    d2_str = ", ".join(format_num_for_display(x) for x in details["d2"]) 
    col_l, col_r = st.columns([2, 3])
    with col_l:
        st.latex(r"\textbf{Second\ differences:}\ %s" % d2_str)
    with col_r:
        st.write(details.get("step_texts", {}).get("what_differences", ""))
    
    if show_teacher_notes:
        with st.expander("ðŸ“š Teacher Notes (Step 2)"):
            st.write("**Second differences:** If these are constant, the sequence is quadratic. This is the CAPS-endorsed method for "
                    "identifying quadratic sequences at Grade 11. Constant second difference is the hallmark of quadratic behaviour.")

    # Show second difference reasoning
    second_diff = details["d2"][0]
    col_l, col_r = st.columns([2, 3])
    with col_l:
        st.latex(r"\text{Second difference} = %s \Rightarrow a = \frac{%s}{2} = %s" % (
            format_num_for_display(second_diff), format_num_for_display(second_diff), format_num_for_display(a)
        ))
    with col_r:
        st.write("STEP 3 â€” Determine 'a': For quadratic sequences the second difference equals 2a, so divide by 2 to find a.")
    
    if show_teacher_notes:
        with st.expander("ðŸ“š Teacher Notes (Step 3)"):
            st.write(details.get("step_texts", {}).get("teacher_note_a", ""))

    # Show solving for b and c using T1 and T2
    T1 = details["sequence"][0]
    T2 = details["sequence"][1]
    col_l, col_r = st.columns([2, 3])
    with col_l:
        st.latex((r"a + b + c = %s" % format_num_for_display(T1)) + " ...equation (1)" )
        st.latex((r"4a + 2b + c = %s" % format_num_for_display(T2)) + " ...equation (2)" )
    with col_r:
        st.write("STEP 4 â€” Form two equations by substituting n=1 and n=2 into T(n)=an^2+bn+c.")
    
    if show_teacher_notes:
        with st.expander("ðŸ“š Teacher Notes (Step 4)"):
            st.write(details.get("step_texts", {}).get("teacher_note_equations", ""))

    col_l, col_r = st.columns([2, 3])
    with col_l:
        st.latex(r"(4a+2b+c) - (a+b+c) = 3a + b = %s" % format_num_for_display(T2 - T1))
        st.latex(r"b = %s - 3\times %s = %s" % (format_num_for_display(T2 - T1), format_num_for_display(a), format_num_for_display(b)))
    with col_r:
        st.write(details.get("step_texts", {}).get("compute_b", ""))
    
    if show_teacher_notes:
        with st.expander("ðŸ“š Teacher Notes (Step 5 â€” Finding b)"):
            st.write(details.get("step_texts", {}).get("teacher_note_b", ""))

    col_l, col_r = st.columns([2, 3])
    with col_l:
        st.latex(r"c = %s - %s - %s = %s" % (format_num_for_display(T1), format_num_for_display(a), format_num_for_display(b), format_num_for_display(c)))
    with col_r:
        st.write(details.get("step_texts", {}).get("compute_c", ""))
    
    if show_teacher_notes:
        with st.expander("ðŸ“š Teacher Notes (Step 6 â€” Finding c)"):
            st.write(details.get("step_texts", {}).get("teacher_note_c", ""))

    # Verification
    col_l, col_r = st.columns([2, 3])
    with col_l:
        st.latex(r"\text{Verification (generated terms)}: %s" % (", ".join(format_num_for_display(x) for x in details.get("generated", []))))
    with col_r:
        st.write(details.get("step_texts", {}).get("verification", ""))
    
    if show_teacher_notes:
        with st.expander("ðŸ“š Teacher Notes (Step 7 â€” Verification)"):
            st.write(details.get("step_texts", {}).get("teacher_note_verification", ""))



def main() -> None:
    st.title("Quadratic Sequence Tutor")
    st.write("Enter the first terms of a quadratic sequence (at least 3 terms). The app will find the general term T(n)=an^2+bn+c and show step-by-step reasoning.")

    # Mode selection
    mode = st.radio("Select mode:", ["Student (solve)", "Teacher (with notes & quizzes)"], index=0)
    show_quizzes = mode == "Teacher (with notes & quizzes)"
    show_teacher_notes = mode == "Teacher (with notes & quizzes)"

    seq_input = st.text_input("Sequence terms (comma-separated, e.g. 3, 8, 15, 24)", value="1,4,9,16")
    show_steps = st.checkbox("Show detailed steps", value=True)
    compute_button = st.button("Compute general term")

    def compute_and_display_from_list(seq: List[float]):
        try:
            a, b, c, details = compute_quadratic_from_terms(seq)
        except ValueError as e:
            st.error(f"Error: {e}")
            return

        if show_steps:
            st.subheader("Step-by-step explanation")
            display_steps(details, a, b, c, show_teacher_notes=show_teacher_notes, show_quizzes=show_quizzes)

        st.subheader("Result")
        st.latex(r"T(n) = %s" % latex_polynomial_elegant(a, b, c))
        st.write(f"Computed coefficients: a = {format_num_for_display(a)}, b = {format_num_for_display(b)}, c = {format_num_for_display(c)}")

        # allow user to compute further terms or specific nth term
        st.subheader("Explore")
        n = st.number_input("Compute T(n) for n =", min_value=1, value=len(seq) + 1, step=1)
        Tn = a * (n ** 2) + b * n + c
        st.write(f"T({n}) = {format_num_for_display(Tn)}")

        count = st.number_input("Generate next how many terms?", min_value=0, value=3, step=1)
        if count > 0:
            start = len(seq) + 1
            more = [a * (i ** 2) + b * i + c for i in range(start, start + count)]
            st.write("Next terms:", [format_num_for_display(x) for x in more])

    if compute_button:
        # parse input
        try:
            seq = [float(x.strip()) for x in seq_input.split(",") if x.strip() != ""]
            if len(seq) < 3:
                st.error("Please enter at least 3 terms.")
            else:
                compute_and_display_from_list(seq)
        except ValueError as e:
            st.error(f"Error parsing input: {e}")

    # Examples section
    with st.expander("Examples & Practice"):
        st.write("Choose an example sequence to load a worked example:")
        examples = {
            "Squares (1,4,9,16)": [1, 4, 9, 16],
            "Starts at 3 (3,8,15,24)": [3, 8, 15, 24],
            "Shifted (2,7,14,23)": [2, 7, 14, 23],
        }
        choice = st.selectbox("Select example:", list(examples.keys()))
        if st.button("Load example"):
            ex_seq = examples[choice]
            seq_input = ",".join(format_num_for_display(x) for x in ex_seq)
            # show what was loaded and compute
            st.write("Loaded sequence:", seq_input)
            compute_and_display_from_list(ex_seq)


if __name__ == "__main__":
    main()
